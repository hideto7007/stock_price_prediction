import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import torch
import torch.nn as nn

from common.common import LSTM, StockPriceData


class Train:
    def __init__(self, data):
        self.data = data
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        
    def min_max_scaler(self):
        # TBD：どの数値データ使うか後で決める
        price_data = self.data['Price']
        
        # データの正規化
        scaler = MinMaxScaler(feature_range=(-1, 1))
        data_scaled = scaler.fit_transform(price_data.values.reshape(-1,1))
        
        return data_scaled
    
    def data_split(self, data_scaled):
        train_size = int(len(data_scaled) * 0.7)
        val_size = int(len(data_scaled) * 0.2)
        test_size = len(data_scaled) - (train_size + val_size)

        train_data = data_scaled[:train_size]
        val_data = data_scaled[train_size:train_size+val_size]
        test_data = data_scaled[-test_size:]
        
        return train_data, val_data, test_data
    
    def train(self, train_data, val_data):
        model = LSTM().to(self.device)
        loss_function = nn.MSELoss()
        optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

        # 訓練ループ
        epochs = 150
        best_val_loss = float("inf")
        best_model = None

        for epoch in range(epochs):
            model.train()
            for seq, labels in train_data:
                seq, labels = seq.to(device), labels.to(device)
                optimizer.zero_grad()
                y_pred = model(seq)
                loss = loss_function(y_pred, labels)
                loss.backward()
                optimizer.step()

            # 検証損失の計算
            model.eval()
            val_loss = 0
            with torch.no_grad():
                for seq, labels in val_data:
                    seq, labels = seq.to(device), labels.to(device)
                    y_pred = model(seq)
                    val_loss += loss_function(y_pred, labels).item()
            val_loss /= len(val_data)

            # 最良のモデルを保存
            if val_loss < best_val_loss:
                best_val_loss = val_loss
                best_model = model.state_dict()

        print(f'Best validation loss: {best_val_loss}')
        
        